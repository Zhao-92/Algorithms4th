# JVM学习整理

---

## 编译、解释

## JVM内存结构

## 对象详解

## 垃圾回收

## 内置命令整理







## 七 虚拟机类加载机制

----

### 一 概述

虚拟机把类的数据从class文件中加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制

#### 二 类加载的时机

类从加载到虚拟机内存中开始，一直到被卸载出内存为止，整个生命周期包括：加载（Loading）、验证（Verfication）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）七个阶段。其中验证、准备、解析统称为链接（Linking）

其中，解析阶段并不一定是按照这个七个阶段顺序执行，他在某些情况下可以在初始化阶段之后再开始，这样做是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）

加载的时机：Java虚拟机规范中并没有明确规定，交由虚拟机的具体实现来自由把握。不过对于初始化阶段，虚拟机进行了严格规定，当遇到下面五种情况的时候必须立即进行初始化，当然初始化之前必须先完成加载、验证、准备工作：

- 遇到new、getstatic、putstatic、incokestatic这4条字节码指令时，如果这个类还没有初始化
- 使用java.lang.reflect包反射调用时
- 初始化一个类的时候，如果其父类还未初始化，会先初始化父类
- 虚拟机启动时会先初始化执行主类（main方法的类）
- 使用JDK1.7的动态语言支持时的一些情况下

tips：当一个接口初始化的时候并不要求父接口进行初始化，只有在真正使用父接口时才初始化

### 三 类加载过程

#### 3.1 加载

在加载阶段主要完成下面三个过程：

- 通过类的全限定名读取定义此类的二进制字节流（.class文件）
- 将二进制字节流中的数据转化为方法区的运行时数据结构
- 在虚拟机内存中生成这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

相对于类加载过程的其他阶段，一个非数组类的加载阶段是程序员可控性最强的。可以自己自定义类加载器，重写loadClass（）方法。

这里比较特殊的是数组类，数组类本身不通过类加载创建，它是由Java虚拟机直接创建的；数据类中的元素类型（例如String[ ] 中的String）最终还是要靠类加载器去创建。

#### 3.2 验证

验证的目的是为保证Class文件中二进制流包含的信息是符合JVM规范的。它主要包括以下四个阶段的验证：

- 文件格式验证

  验证字节流是否符合Class文件格式的规范，魔术、版本号、常量池等等

- 元数据校验

  主要对二进制字节码描述的信息进行语义分析，保证符合java语法，主要是方法体之外的语法。如：是否实现了父类的抽象方法，是否有错误的继承等等

- 字节码验证

  主要目的是通过数据流和控制流Fenix，确定程序语义是合法、符合逻辑的

- 符号引用验证

  符号引用验证发生在虚拟机将符号引用转化为直接饮用的时候这个转化动作将在连接的第三个阶段——解析阶段中发生

#### 3.3 准备

准备阶段正式为**类变量**分配内存并进行初始化赋值（系统初始值），分配的内存都在方法区中。这个阶段只为类变量分配内存，而不包括实例变量，实例变量的会在对象实例化时随对象一起分配在Java堆中。

```java
public static int value = 123;
```

例如这个类变量value，在准备阶段将会为他分配方法区内存，并为他赋初始值0。JVM将给value赋值123的操作，存放于类构造器**clinit( )**方法中，并于初始化阶段执行

#### 3.4 解析

解析阶段主要是将常量池内的符号引用替换为直接引用的过程。解析阶段只会把一部分符号引用（）转化为直接引用，这种转化叫做**静态解析**；另外一部分将在运行期间转化为直接引用，这种转化叫做动态**连接**

**符号引用**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可

**直接引用**：直接引用可以是指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。直接引用所引用的目标一定是在内存中已经存在的

一般来说符号引用就是Class文件中常量池内的定义的常量，在Class文件中这些符号引用仅仅只是一个字符型常量，没有引用到任何其他地方，而直接引用是引用到具体的实例中的

解析动作主要针对：类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符7种

#### 3.5 初始化

初始化阶段是类加载过程最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作都是完全由虚拟机主导和控制的。到了初始化阶段，才真正开始执行类中定义的Java程序代码

初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，换句话说就是执行类加载器clinit( )方法

- clinit( )方法是编译器自动收集类中所有**类变量的赋值动作**和**静态代码块**中的语句合并而成。收集的顺序就是按照源文件中语句的顺序。对于定义在静态代码块之前的变量，静态代码块只能赋值，不能访问

- clinit( )方法和init( )方法不同，他不需要显示地调用父类的clinit( )方法，因为父类已经在他之前初始化过了。因此虚拟机中第一个被执行的clinit( )方法肯定是java.lang.Object类的


tip：clinit( ) 和 init( )

clinit( )称为类构造器，在初始化阶段运行，主要给类变量赋值、运行静态代码块

init( )称为实例构造器，就是我们平时说的构造函数，在显式调用类构造函数时运行，完成实例变量的初始化

父类、子类执行顺序

1. 父类的静态初始化块
2. 子类的静态初始化块
3. 父类的初始化块
4. 父类的构造函数
5. 子类的初始化块
6. 子类的构造函数



### 四 类加载器

类加载阶段“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部实现。类实现这个动作的代码模块就叫做“类加载器”，执行类加载器之后得到当前类的Class对象

#### 4.1 类和类加载器

每个类加载器都拥有一个自己独立的类命名空间，对于虚拟机中任何一个类都需要类加载器 + 类本身(对应的Class文件)来确立其唯一性。即使两个类源于同一个Class文件，被同一个虚拟机加载，但是是两个不同的类加载，那这两个类也是不同的

#### 4.2 双亲委派模型

类加载器可以分为两大类：

- 启动类加载器Bootstarp ClassLoader

  使用C++语言实现，是虚拟机的一部分，无法被Java程序员直接调用

- 其他类加载器

  都是继承自抽象类java.lang.ClassLoader，由Java语言实现，独立于虚拟机外部。ClassLoader最主要的方法就是loadClass(String name)通过类限定名，获得Class类的对象

  - 扩展类加载器Extension ClassLoader

    由ExtClassLoader类实现，可以直接调用

  - 应用程序类加载器Application ClassLoader

    由AppClassLoader类实现，可以直接调用

Bootstarp、ExtClassLoader、AppClassLoader三个加载器之间是父子关系，当一个类加载器收到类加载请求时，他首先不会自己去加载，而是请求他的父类加载器去完成加载，当父类加载器无法加载时，他才自己加载。这种方式就叫做“双亲委派模型”。

这样的好处在于，Java类随着的他的类加载器一起具备了一种带有优先级的层级关系。同时也保证了类的唯一性

#### 4.3 破坏双亲委派模型

双亲委派模型不是强制型的，他只是Java设计者推荐给开发者使用的一种类加载方式。

例如：OSGI环境下，类加载器就不再是双亲委派模型的树形结构，而是发展为更加复杂的网状结构



## 八 虚拟机字节码执行引擎

#### 8.1 概述

执行引擎是Java虚拟机最核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎是自己实现的

#### 8.2 运行时栈帧结构

栈帧：用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧出栈入栈的过程就是一个方法从调用开始到执行完成的过程，一个栈帧对应一个方法。

每一个栈帧都包括**局部变量表、操作数栈、动态连接和方法返回地址**这四个主要部分和一些额外的附加信息。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，这个栈帧对应的方法，称为当前方法。在一个方法中调用新的方法时，新方法的栈帧就压入虚拟机栈中，通过栈的先进后出特性，完成方法间的调用和返回。

![JVM_栈帧结构](/Users/ethan/Study/Github/HZ-study/MarkDown/后端/JVM_栈帧结构.png)

##### （1）局部变量表

- 用于存放方法参数和方法内的局部变量（临时变量），局部变量表以变量槽（Slot）为最小单位
- 局部变量表是通过索引访问的，其中第0位索引是默认用于传递方法所属对象实例的引用（也就是this）
- 为了节省空间，局部变量表中的空间是重复利用的，当程序执行到某个变量a的作用域之外时，新的变量b可以覆盖到这个变量a所在的Slot上（在b覆盖a之前，即使程序执行位置已经出了a的作用域，GC仍不会回收a，因为局部变量表中依然有a的引用，局部变量表是GC Roots的一部分）
- 局部变量使用前，必须先进行赋值

##### （2）操作数栈 

一个方法方开始执行的时候，这个方法的操作数栈都是空的，在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，对应入栈出栈操作。说白了，我们在程序方法中写的代码，最终都在操作数栈中执行

##### （3）动态连接 

每个栈帧中都保留了指向运行时常量池中该栈帧所属方法的引用，这个引用就是用来支持程序运行时进行动态连接的。我们知道在Class文件的常量池中存有大量的符号引用，这些符号引用需要转化为直接引用才能被使用，转化的过程分为两种：

- 静态解析：这些符号引用一部分在类加载阶段或者第一次使用的时候就转化为直接引用
- 动态链接：无法进行的静态解析的引用（方法重写），将在每一次运行期间转化为直接引用，这部分称为动态链接

##### 方法返回地址

一个方法开始执行后，有两种方式退出：方法放回字节码指令（就是return）和执行异常退出。两种方式在退出之后，都会回到方法被调用的位置，继续执行，不同在于第一种有返回值，第二种没有返回值

一个方法返回后，方法对应的栈帧就从虚拟机栈中出栈，之后恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向调用指令后面的一条指令

#### 8.3 方法调用

方法调用阶段唯一要做的事情就是确定被调用方法的版本（重写/重载的方法就有多个版本）。JAVA语言在编译时不包含传统编译过程中的连接操作，而是通过**类加载中的解析**和**执行过程中的动态连接**完成。

总结来看方法调用通过：编译期静态分派，类加载期解析，执行期动态分派

##### 解析

类加载过程中的解析阶段只会把一部分符号引用转化为直接引用，被转化的引用必须满足：方法在程序真正运行之前就有一个确定的(可确定是对于方法而言的)调用版本，并且这个版本的方法在运行时不可改变，也就是“编译期可知，运行期不变”，。满足这个条件的方法有：静态方法、私有方法、父类方法、实例构造器，final修饰的方法，这五类方法称为“非虚方法”。剩余其他方法叫做“虚方法”。

与之相对应的在虚拟机中有五种方法调用字节码指令：

- invokestatic：调用静态方法
- invokespecial：调用<init>方法，私有方法，父类方法
- invokevirtual：调用所有虚方法
- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象
- invokedynamic：？？

##### 分派

分派调用的过程揭示了Java作为面向对象的多态性特征。分派分为：静态分派和动态分派，分别对应静态多态和动态多态。方法重载和方法重写的实现过程就是静态分派和动态分派的实现过程。

（1）静态分派

静态分派是围绕重载overload进行的。

```java
Human man = new Man();
```

上面代码中"Human"称为变量的静态类型，也叫做外观类型；"Man"称为实际类型。

所有依赖静态类型来定位方法执行版本的分派动作都称为静态分派调用，他发生在编译阶段，因此确定静态分派的动作并不是由虚拟界来执行的。静态分派的典型应用就是方法重载。

静态分派和解析并不冲突，例如对于重载的静态方法，编译时静态分派确定重载版本，解析时确定直接引用

（2）动态分派

动态分派是围绕重写override进行的。

invokevirtual指令的多态查找过程完成动态分派，把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中**方法重写的本质**。invokevirtual指令执行过程：

- 获取操作栈顶第一个元素所指向的对象的实际类型C
- 在C中查找是否有匹配的方法，找到后进行访问权限校验，校验通过就返回直接引用，查询结束；校验不通过就报错java.lang.IllegalAccessError
- C中未找到，就在父类中进行第二步
- 如果找到最上面的父类依然没有找到匹配的方法，就报错java.lang.AbstarctMethodError

（3）单分派和多分派

（4）虚拟机动态分派的实现

上面的动态分派中讲了invokevirtual是如何进行搜索的，这是虚拟机概念模型中的方法。但由于动态分配是非常频繁的操作，出于性能的考虑，实际中不会频繁的的进行搜索。最常用的稳定手段就是为类在方法区建立一个**虚方法表**，同样也会为接口建立一个**接口方法表**。方法表里存放了当前类/接口所能调用到的所有方法的实际入口地址（运行时数据区的方法区）

![JVM_虚方法表](/Users/ethan/Study/Github/HZ-study/MarkDown/后端/JVM_虚方法表.jpg)

方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把类的虚方法表也初始化完毕














